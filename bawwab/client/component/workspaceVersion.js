import { translations, i18nMixin } from '../i18n.js';
import { store } from '../app.js';
import { queryParamProp, CancelledError } from '../utils.js';
import { BorgErrorNonexistent } from '../borg.js';
import { nextTick } from 'vue/dist/vue.esm-bundler.js';
import NaturalAgoComponent from '../component/naturalAgo.js';
import ChangeProxy from '../changeProxy.js';

export default {
	name: 'WorkspaceVersion',
	props: ['wsid'],
	data: _ => ({
		state: store.state,
		cancel: null,
		/* name of the backup that is currently editable */
		editable: [],
		/* input models */
		newName: {},
		newComment: {},
		/* name of the backup to highlight */
		highlight: null,
		selected: [],
		selectAll: false,
		strings: translations ({
			de: {
				'title': 'Sicherungen',
				'nonexistent': 'Bisher existieren keine Sicherungen.',
				'close': 'Schließen',
				'autogenerated': 'Automatische Sicherung',
				'manual': 'Manuelle Sicherung',
				'namePlaceholder': 'Name',
				'commentPlaceholder': 'Kommentar',
				'delete': 'Löschen',
				'restore': 'Wiederherstellen',
				'edit': 'Bearbeiten',
				'save': 'Speichern',
				},
			en: {
				'title': 'Versions',
				'nonexistent': 'So far no saved versions exist.',
				'close': 'Close',
				'autogenerated': 'Autogenerated version',
				'manual': 'User-initiated version',
				'namePlaceholder': 'Name',
				'commentPlaceholder': 'Comment',
				'delete': 'Delete',
				'restore': 'Restore',
				'edit': 'Edit',
				'save': 'Save',
				},
			}),
	}),
	mixins: [i18nMixin],
	template: `<div>
	<p v-if="nonexistent || !archives">{{ t('nonexistent') }}</p>
	<div class="versions" v-else>
	<table>
		<thead>
			<tr>
				<th class="select"><input type="checkbox" v-model="selectAll"></th>
				<th colspan="3">
					<action-button v-if="editable.length > 0" :f="rename" icon="save" importance="low" class="save">{{ t('save') }}</action-button>
					<action-button v-else :f="makeEditable" icon="edit" importance="low" :disabled="noElementSelected">{{ t('edit') }}</action-button>
					<action-button :f="removeSelected" icon="trash" importance="low" :disabled="noElementSelected">{{ t('delete') }}</action-button>
					<action-button :f="restoreSelected" icon="undo" importance="low" :disabled="restoreDisabled">{{ t('restore') }}</action-button>
				</th>
			</tr>
		</thead>
		<tbody>
		<tr v-for="v of archives">
			<!-- Use the name from the original object (i.e. underscore), so editing the input won’t change this identifier -->
			<td class="select"><input v-model="selected" type="checkbox" name="selected" :value="v._.name"></td>
			<td class="date"><ago :date="v.date"></ago></td>
			<td class="name">
				<template v-if="editable.includes (v._.name)">
					<input v-model="v.name" class="name" required :placeholder="t('namePlaceholder')"><br>
				</template>
				<template v-else>
					{{ renameAuto (v.name) }} <i class="fas fa-check" v-if="highlight == v.name"></i>
				</template>
			</td>
			<td class="comment">
				<input v-if="editable.includes (v._.name)" v-model="v.comment" class="comment" :placeholder="t('commentPlaceholder')">
				<span v-else-if="v.comment">{{ v.comment }}</span>
			</td>
		</tr>
		</tbody>
	</table>
	</div>
</div>`,
	components: {
		'ago': NaturalAgoComponent,
	},
	created: async function () {
		await this.state.ready.wait ();
		await this.state.borg.list (this.workspace);
	},
	computed: {
		workspaces: function () { return this.state.workspaces; },
		workspace: function () {
			return this.workspaces ? this.workspaces.getById (this.wsid) : null;
		},
		repository: function () { return this.state.borg.get (this.workspace.path); },
		nonexistent: function () { return this.repository instanceof BorgErrorNonexistent; },
		archivesMap: function () {
			if (!this.repository || this.repository instanceof Error) {
				return this.repository;
			} else {
				const m = new Map ();
				this.repository.archives.forEach (function (v, k) {
					m.set (k, new ChangeProxy (v));
				});
				return m;
			}
		},
		archives: function () {
			if (!this.archivesMap || this.archivesMap instanceof Error) {
				return this.archivesMap;
			} else {
				const v = Array.from (this.archivesMap.values ());
				/* Sort by date, latest one first */
				v.sort ((a, b) => a.date > b.date ? -1 : 1);
				return v;
			}
		},
		noElementSelected: function () {
			return !(this.selected.length > 0 && this.editable.length == 0);
		},
		restoreDisabled: function () {
			return !(this.selected.length == 1 && this.editable.length == 0);
		},
	},
	methods: {
		renameAuto: function (s, empty=false) {
			if (s.startsWith ('auto-')) {
				return this.t('autogenerated');
			} else if (s.startsWith ('manual-')) {
				return this.t('manual');
			} else {
				return s;
			}
		},
		makeEditable: async function (newname) {
			/* Must be a copy, so selection does not change editability */
			this.editable = Array.from (this.selected);
		},
		versionFromName: function (name) {
			return this.archivesMap.get (name);
		},
		rename: async function () {
			const changed = [];
			for (const n of this.editable) {
				const v = this.versionFromName (n);
				if (!v) {
					continue;
				}
				changed.push (v);
			}
			/* As soon as we start editing, archivesMap is updated and returns new Proxy objects with old values. So we have to save all modified BorgArchive objects first and then apply the changes. Urgh. */
			for (const v of changed) {
				/* first change the comment, then the name. Otherwise we have to remember to use the new name. */
				if (v.comment != v._.comment) {
					await this.state.borg.changeComment (this.workspace, v._, v.comment);
				}
				if (v.name != v._.name) {
					await this.state.borg.rename (this.workspace, v._, v.name);
				}
				/* The change is applied to the model by the repo operations above */
				v.reset ();
			}
			this.editable = [];
			this.selected = [];
			this.highlight = null;
		},
		restoreSelected: async function () {
			const restoreName = this.selected[0];
			await this.state.borg.extract (this.workspace, this.versionFromName (restoreName));
			this.selected = [];
			this.highlight = restoreName;
		},
		/* We cannot call this method “delete” for some reason. It will
		 * behave weirdly. Maybe it collides with some builtin? */
		removeSelected: async function () {
			await this.state.borg.delete (this.workspace, this.selected.map (this.versionFromName));
			this.editable = [];
			this.selected = [];
			this.highlight = null;
		},
	},
	watch: {
		selectAll: function () {
			if (this.selectAll) {
				this.selected = this.archives.map (v => v.name);
			} else {
				this.selected = [];
			}
		},
	},
};

